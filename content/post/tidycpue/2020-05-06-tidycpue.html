---
title: Tidyverse for simple CPUE standardizations
author: ~
date: '2020-01-23'
slug: tidycpue
categories: []
tags: []
subtitle: ''
summary: ''
authors: []
lastmod: '2020-05-06T15:36:27-07:00'
featured: yes
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---



<p>My first CPUE standardization code was several hundred lines long. By hand, I fit individual glm models with different combinations of predictor variables, laboriously checking the AIC values of each added step and starting a new chunk of tested models based on the best one. I knew even then that some of this work could have been automated using something like MuMIn::dredge(), but that did not inspect the order of predictors added and interaction terms, among other things.</p>
<p>From here at <code>rstudio::conf(2020)</code> where I’m happy to be attending as a Diversity Scholar, I whipped up a tidyverse solution to these qualms. Max Kuhn et al have extensive dox explaining how this very basic (i.e. fixed effects) framework can be re-framed into a mixed-effects or stan setup. The code below is effectively a tenth of what I did before, and automates the checking of many models specified via fit_with using or ignoring interactive terms. At the end I use purrr::map to calculate AIC on all at once, extract and plot outputs. I load a few packages up top but really you could do this with fewer if you plotted in base and had your own AIC function.</p>
<p>If you look into the cpue_fits object, you get a neat summary of every model specified, no for-loops required</p>
<p>Disclaimer: this data is totally fake, and the point here isn’t whether or not the model makes the most sense from a CPUE standpoint. I fudged it a bit so the CPUE actually tracks fairly well with catch.</p>
<div class="figure">
<img src="../tidycpue.png" />

</div>
<pre class="r"><code>## Tidy CPUE
require(lunar)
require(MuMIn)
require(ggplot2)
require(modelr)
require(tidyverse)
require(parsnip)

## generate fake data ----
landings &lt;-  data.frame(expand.grid(YEAR = seq(1956,2015,1),  
                                    VESSEL = c(&#39;Ariel&#39;,&#39;Jasmine&#39;,&#39;Cinderella&#39;,&#39;Elsa&#39;))) %&gt;%
  arrange(.,YEAR) %&gt;%
  mutate(LBS = c(rnorm(0.5*nrow(.),44,4),rnorm(0.1*nrow(.),24,4),
                 rnorm(0.1*nrow(.),34,4),rnorm(0.3*nrow(.),30,4)),
         HOOKS = c(rnorm(0.5*nrow(.),65,4),rnorm(0.1*nrow(.),55,4),
                   rnorm(0.1*nrow(.),70,4),rnorm(0.3*nrow(.),80,4)),
         WIND_SPEED = c(rnorm(0.5*nrow(.),8.5,2),rnorm(0.5*nrow(.),5,4)),
         MOON_PHASE = rep(lunar::lunar.8phases,nrow(.)/8),
         MEAN_TEMP = c(rnorm(0.5*nrow(.),14,4),rnorm(0.1*nrow(.),40,4),
                       rnorm(0.1*nrow(.),20,4),rnorm(0.3*nrow(.),25,4)))

## modelr::fit_with
cpue_fits &lt;- landings %&gt;% 
  modelr::fit_with(lm, formulas(~LBS,
                                base = ~YEAR + VESSEL ,
                                interaction = ~VESSEL * MEAN_TEMP,
                                phase = add_predictors(base, ~MOON_PHASE),
                                full_no_int = add_predictors(base, ~.),
                                full_int = add_predictors(interaction,~.)
))

purrr::map(cpue_fits, parsnip::predict.model_fit, type = &#39;conf_int&#39;)

## extract formula one with the lowest AIC
best_formula &lt;- cpue_fits[[which.min(purrr::map(cpue_fits,AIC))]][&#39;call&#39;][[1]]
best_mod &lt;- linear_reg() %&gt;% set_engine(&quot;lm&quot;) %&gt;%
  fit(formula(best_formula), data = landings)
predict(lm_fit, landings, type = &quot;conf_int&quot;)

## bind predicts and CI to original df
pred_df &lt;- landings %&gt;%
  bind_cols(.,PREDICTS = predict(best_mod, landings)) %&gt;%
  bind_cols(., predict(best_mod ,landings, type = &quot;conf_int&quot;)) 

## clean the DF to get mean annual values

pred_df_clean &lt;- pred_df %&gt;% group_by(YEAR) %&gt;% 
  summarise(meanLBS = mean(LBS), meanCPUE = mean(.pred),
            meanCPUE.lwr = mean(.pred_lower),
            meanCPUE.upr = mean(.pred_upper))


ggplot(pred_df_clean, aes(x = YEAR)) +
  theme_minimal()+
  geom_line(aes(y = meanLBS), col = &#39;black&#39;, lwd = 1.2) +
  geom_point(aes(y = meanCPUE),col = &#39;dodgerblue&#39; ) + 
  geom_errorbar(aes(ymin = meanCPUE.lwr, ymax =meanCPUE.upr),
                col = &#39;dodgerblue&#39; ) +
  labs(x = &#39;Year&#39;, y = &#39;Catch (lbs, black line) or CPUE (blue points and 95%CI&#39;)</code></pre>
