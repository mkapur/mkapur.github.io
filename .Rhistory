# Calculate the mean of the bootstrap sample
bootstrap_means[k] <- sum(bootstrap_sample * (1:n_rows))
# Perform bootstrapping
for (k in 1:n_bootstrap) {
# Sample with replacement from the probabilities column
bootstrap_sample <- sample(probs[, j], replace = TRUE)
# Calculate the mean of the bootstrap sample
bootstrap_means[k] <- sum(bootstrap_sample * (1:n_rows))
}
bootstrap_means
means_est
true_means
# Set the known mean and standard deviation
known_mean <- 5
known_sd <- 1
# Generate the probabilities from a normal distribution
set.seed(123)  # Set seed for reproducibility
probs <- rnorm(10, mean = known_mean, sd = known_sd)
probs <- probs / sum(probs)  # Normalize probabilities to sum to 1
# Calculate the estimated mean and standard deviation
mean_est <- sum(probs * (1:length(probs)))
sd_est <- sqrt(sum(probs * ((1:length(probs)) - mean_est)^2))
# Print the estimated mean and standard deviation
cat("Estimated Mean:", mean_est, "\n")
cat("Estimated Standard Deviation:", sd_est, "\n")
# Plot the comparison
plot(1:length(probs), probs, type = "b", pch = 16, col = "blue",
xlab = "Index", ylab = "Probabilities", main = "True vs Estimated Mean and Standard Deviation")
abline(v = mean_est, col = "red", lwd = 2, lty = 2)
abline(h = known_mean, col = "black", lwd = 2, lty = 2)
legend("topright", legend = c("True Mean", "Estimated Mean"), col = c("black", "red"),
lwd = 2, lty = 2, pch = c(NA, NA), pt.bg = c("black", "red"))
dev.off()
# Set the known mean and standard deviation
known_mean <- 5
known_sd <- 1
# Generate the probabilities from a normal distribution
set.seed(123)  # Set seed for reproducibility
probs <- rnorm(10, mean = known_mean, sd = known_sd)
probs <- probs / sum(probs)  # Normalize probabilities to sum to 1
# Calculate the estimated mean and standard deviation
mean_est <- sum(probs * (1:length(probs)))
sd_est <- sqrt(sum(probs * ((1:length(probs)) - mean_est)^2))
# Print the estimated mean and standard deviation
cat("Estimated Mean:", mean_est, "\n")
cat("Estimated Standard Deviation:", sd_est, "\n")
# Plot the comparison
plot(1:length(probs), probs, type = "b", pch = 16, col = "blue",
xlab = "Index", ylab = "Probabilities", main = "True vs Estimated Mean and Standard Deviation")
abline(v = mean_est, col = "red", lwd = 2, lty = 2)
abline(h = known_mean, col = "black", lwd = 2, lty = 2)
legend("topright", legend = c("True Mean", "Estimated Mean"), col = c("black", "red"),
lwd = 2, lty = 2, pch = c(NA, NA), pt.bg = c("black", "red"))
# Print the estimated mean and standard deviation
cat("Estimated Mean:", mean_est, "\n")
cat("Estimated Standard Deviation:", sd_est, "\n")
# Print the estimated mean and standard deviation
cat("Estimated Mean:", mean_est, "\n")
cat("Estimated Standard Deviation:", sd_est, "\n")
# Print the estimated mean and standard deviation
cat("True Mean:",known_mean, "Estimated Mean:", mean_est, "\n")
cat("True SD:",known_sd,"Estimated Standard Deviation:", sd_est, "\n")
# Plot the comparison
plot(1:length(probs), probs, type = "b", pch = 16, col = "blue",
xlab = "Index", ylab = "Probabilities", main = "True vs Estimated Mean and Standard Deviation")
abline(v = mean_est, col = "red", lwd = 2, lty = 2)
abline(h = known_mean, col = "black", lwd = 2, lty = 2)
legend("topright", legend = c("True Mean", "Estimated Mean"), col = c("black", "red"),
lwd = 2, lty = 2, pch = c(NA, NA), pt.bg = c("black", "red"))
# Print the estimated mean and standard deviation
cat("True Mean:",known_mean, "Estimated Mean:", mean_est, "\n")
cat("True SD:",known_sd,"Estimated Standard Deviation:", sd_est, "\n")
# Print the estimated mean and standard deviation
cat("True Mean:",known_mean, "Estimated Mean:", mean_est, "\n")
cat("True SD:",known_sd,"Estimated Standard Deviation:", sd_est, "\n")
# Generate the probabilities from a normal distribution
set.seed(123)  # Set seed for reproducibility
probs <- rnorm(100, mean = known_mean, sd = known_sd)
probs <- probs / sum(probs)  # Normalize probabilities to sum to 1
# Set the known mean and standard deviation
known_mean <- 5
known_sd <- 1
# Generate the probabilities from a normal distribution
set.seed(123)  # Set seed for reproducibility
probs <- rnorm(100, mean = known_mean, sd = known_sd)
probs <- probs / sum(probs)  # Normalize probabilities to sum to 1
# Calculate the estimated mean and standard deviation
mean_est <- sum(probs * (1:length(probs)))
sd_est <- sqrt(sum(probs * ((1:length(probs)) - mean_est)^2))
# Print the estimated mean and standard deviation
cat("True Mean:",known_mean, "Estimated Mean:", mean_est, "\n")
cat("True SD:",known_sd,"Estimated Standard Deviation:", sd_est, "\n")
# Plot the comparison
plot(1:length(probs), probs, type = "b", pch = 16, col = "blue",
xlab = "Index", ylab = "Probabilities", main = "True vs Estimated Mean and Standard Deviation")
abline(v = mean_est, col = "red", lwd = 2, lty = 2)
abline(h = known_mean, col = "black", lwd = 2, lty = 2)
legend("topright", legend = c("True Mean", "Estimated Mean"), col = c("black", "red"),
lwd = 2, lty = 2, pch = c(NA, NA), pt.bg = c("black", "red"))
hist(probs)
100
probs
(1:length(probs))
# Calculate the estimated mean and standard deviation
mean_est <- sum(probs * (1:length(probs)))
sd_est <- sqrt(sum(probs * ((1:length(probs)) - mean_est)^2))
# Set the known mean and standard deviation
n_bins = 1000
known_mean <- n_bins*0.45
known_sd <- n_bins*0.1
# Generate the probabilities from a normal distribution
set.seed(123)  # Set seed for reproducibility
probs <- rnorm(n_bins, mean = known_mean, sd = known_sd)
probs <- probs / sum(probs)  # Normalize probabilities to sum to 1
# Calculate the estimated mean and standard deviation
mean_est <- sum(probs * (1:length(probs)))
sd_est <- sqrt(sum(probs * ((1:length(probs)) - mean_est)^2))
# Print the estimated mean and standard deviation
cat("True Mean:",known_mean, "Estimated Mean:", mean_est, "\n")
cat("True SD:",known_sd,"Estimated Standard Deviation:", sd_est, "\n")
# Plot the comparison
plot(1:length(probs), probs, type = "b", pch = 16, col = "blue",
xlab = "Index", ylab = "Probabilities", main = "True vs Estimated Mean and Standard Deviation")
abline(v = mean_est, col = "red", lwd = 2, lty = 2)
abline(h = known_mean, col = "black", lwd = 2, lty = 2)
legend("topright", legend = c("True Mean", "Estimated Mean"), col = c("black", "red"),
lwd = 2, lty = 2, pch = c(NA, NA), pt.bg = c("black", "red"))
# Generate the probability matrix
n_rows <- 10
n_cols <- 10
true_means <- (1:abins)+0.25  # True means for each column
true_sds <- seq(0.5, 1.5, length.out = n_cols)  # True standard deviations for each column
probs <- matrix(0, nrow = n_rows, ncol = n_cols)
for (j in 1:n_cols) {
probs[, j] <- dnorm(1:n_rows, mean = true_means[j], sd = true_sds[j])
probs[, j] <- probs[, j] / sum(probs[, j])  # Normalize probabilities to sum to 1
}
# Estimate the means for each column
means_est <- numeric(n_cols)
for (j in 1:n_cols) {
init_mean <- 0  # Initial mean value for optimization
# Define the objective function for the current column
objective_col <- function(mean) {
# random_vals <- dnorm(1:n_rows, mean = mean, sd = true_sd)
random_vals <- random_vals / sum(random_vals)
sum_sq_diff <- sum((probs[, j] - random_vals)^2)
return(sum_sq_diff)
}
optim_result <- optimize(f = objective_col, interval = c(-10, 10))
means_est[j] <- optim_result$minimum
}
# Generate the probability matrix
n_rows <- 10
n_cols <- 10
true_means <- (1:abins)+0.25  # True means for each column
true_sds <- seq(0.5, 1.5, length.out = n_cols)  # True standard deviations for each column
probs <- matrix(0, nrow = n_rows, ncol = n_cols)
for (j in 1:n_cols) {
probs[, j] <- dnorm(1:n_rows, mean = true_means[j], sd = true_sds[j])
probs[, j] <- probs[, j] / sum(probs[, j])  # Normalize probabilities to sum to 1
}
# Estimate the means for each column
means_est <- numeric(n_cols)
for (j in 1:n_cols) {
init_mean <- 0  # Initial mean value for optimization
# Define the objective function for the current column
objective_col <- function(mean) {
random_vals <- dnorm(1:n_rows, mean = mean, sd = true_sd)
random_vals <- random_vals / sum(random_vals)
sum_sq_diff <- sum((probs[, j] - random_vals)^2)
return(sum_sq_diff)
}
optim_result <- optimize(f = objective_col, interval = c(-10, 10))
means_est[j] <- optim_result$minimum
}
# Estimate the standard deviations for each column
sds_est <- numeric(n_cols)
for (j in 1:n_cols) {
# Define the objective function for the current column
objective_sd <- function(sd) {
random_vals <- dnorm(1:n_rows, mean = means_est[j], sd = sd)
random_vals <- random_vals / sum(random_vals)
sum_sq_diff <- sum((probs[, j] - random_vals)^2)
return(sum_sq_diff)
}
optim_result_sd <- optimize(f = objective_sd, interval = c(0, 10), maximum = FALSE)
sds_est[j] <- optim_result_sd$minimum
}
# Print the estimated means and standard deviations
rbind(means_est, true_means)
rbind(sds_est, true_sds)
par(mfrow = c(1, 2))
# Plot true vs estimated means
plot(1:n_cols, true_means, type = "l", col = "black", lwd = 2,
ylim = c(min(true_means, means_est, na.rm = TRUE) - 1, max(true_means, means_est, na.rm = TRUE) + 1),
xlab = "Column", ylab = "Mean", main = "True vs Estimated Means")
points(1:n_cols, means_est, col = "blue", pch = 16)
legend("topright", legend = c("True", "Estimated"), col = c("black", "blue"), lwd = 2, pch = 16)
# Plot true vs estimated standard deviations
plot(1:n_cols, true_sds, type = "l", col = "black", lwd = 2,
ylim = c(min(true_sds, sds_est, na.rm = TRUE) - 0.5, max(true_sds, sds_est, na.rm = TRUE) + 0.5),
xlab = "Column", ylab = "Standard Deviation", main = "True vs Estimated Standard Deviations")
points(1:n_cols, sds_est, col = "blue", pch = 16)
legend("topright", legend = c("True", "Estimated"), col = c("black", "blue"), lwd = 2, pch = 16)
# Set the known mean and standard deviation
n_bins = 50
known_mean <- n_bins*0.45
known_sd <- n_bins*0.1
# Generate the probabilities from a normal distribution
set.seed(123)  # Set seed for reproducibility
probs <- rnorm(n_bins, mean = known_mean, sd = known_sd)
probs <- probs / sum(probs)  # Normalize probabilities to sum to 1
# Calculate the estimated mean and standard deviation
mean_est <- sum(probs * (1:length(probs)))
sd_est <- sqrt(sum(probs * ((1:length(probs)) - mean_est)^2))
# Print the estimated mean and standard deviation
cat("True Mean:",known_mean, "Estimated Mean:", mean_est, "\n")
cat("True SD:",known_sd,"Estimated Standard Deviation:", sd_est, "\n")
# Plot the comparison
plot(1:length(probs), probs, type = "b", pch = 16, col = "blue",
xlab = "Index", ylab = "Probabilities", main = "True vs Estimated Mean and Standard Deviation")
abline(v = mean_est, col = "red", lwd = 2, lty = 2)
abline(h = known_mean, col = "black", lwd = 2, lty = 2)
legend("topright", legend = c("True Mean", "Estimated Mean"), col = c("black", "red"),
lwd = 2, lty = 2, pch = c(NA, NA), pt.bg = c("black", "red"))
# Generate the probability matrix
n_rows <- 10
n_cols <- 10
true_means <- (1:abins)+0.25  # True means for each column
# knitr::opts_chunk$set(echo = FALSE)
options(knitr.table.format = function() {
if (knitr::is_latex_output()) 'latex' else 'pandoc'
})
require(reshape2)
require(dplyr)
require(ggplot2)
abins <- 10
# bias_a <- sort(sapply(1:abins, FUN = function(x) rnorm(1, mean = x, sd = 0.1)))
bias_a <- c(1.1873,	2.2105,	3.23844,	4.27116,	5.30867,	6.351,	7.39816,	8.45019,	9.5071, 10.6357)
sd_a <- rep(0.15, abins)
# sd_a <- c(	0.001, 0.0716628,	0.142271,	0.212825,	0.283324,	0.353768,	0.424158,	0.494494,	0.564775,0.635002)
# sd_a <- sapply(1:abins, FUN = function(x) 0.001+0.005*x)
par(mfrow=c(1,2))
plot( 1:abins,bias_a, type = 'l', xlab = 'true age', ylab = 'bias')
plot( 1:abins, sd_a, type = 'l', xlab = 'true age', ylab = 'sd')
P_aa <- matrix(0, nrow = abins, ncol = abins)
diag(P_aa) <- 1
P_aa
getP_al <- function(theta, aa, sigma, maxage){
pal = NA
if(theta == 1){
pal <- pnorm(theta, aa, sigma)
} else if (theta > 1 & theta < maxage){
pal <- pnorm(theta+1, aa, sigma) - pnorm(theta, aa, sigma)
} else if (theta == maxage){
pal <- 1-pnorm(theta, aa, sigma)
}
pal
}
for(a_obs in 1:abins){
for(a_tilde in 1:abins){
P_aa[a_obs,a_tilde] <- getP_al(theta = a_obs,
aa = bias_a[a_tilde],
sigma = sd_a[a_tilde],
maxage = abins)
} ## aprime
} ## aobs
P_aa[1,1] <- 1
for(a_obs in 1:abins){
P_aa[,a_obs] <- P_aa[,a_obs]/sum(P_aa[,a_obs])
}
all(round(colSums(P_aa))==1)
melt_paa <- melt(P_aa)
ggplot(data = melt_paa, aes(x = Var1, y = value, color = factor(Var2))) +
theme_minimal() +
geom_line(lwd = 1)+
scale_color_grey() +
labs(x = 'True Age', y = 'Probability', color = 'Read Age')
ggplot(data = melt_paa, aes(y = Var1, x = Var2, fill = value)) +
theme_minimal()+
theme(legend.position = 'none')+
geom_tile()+
coord_equal()+
scale_y_reverse() +
scale_x_continuous(position = 'top')+
geom_text(aes(label = round(value, 3)), color = 'yellow', size = 3)+
scale_color_grey() +
labs(x = 'Read Age', y = 'True Age', color = 'Prob')
# Set the known mean and standard deviation
n_bins = 50
known_mean <- n_bins*0.45
known_sd <- n_bins*0.1
# Generate the probabilities from a normal distribution
set.seed(123)  # Set seed for reproducibility
probs <- rnorm(n_bins, mean = known_mean, sd = known_sd)
probs <- probs / sum(probs)  # Normalize probabilities to sum to 1
# Calculate the estimated mean and standard deviation
mean_est <- sum(probs * (1:length(probs)))
sd_est <- sqrt(sum(probs * ((1:length(probs)) - mean_est)^2))
# Print the estimated mean and standard deviation
cat("True Mean:",known_mean, "Estimated Mean:", mean_est, "\n")
cat("True SD:",known_sd,"Estimated Standard Deviation:", sd_est, "\n")
# Plot the comparison
plot(1:length(probs), probs, type = "b", pch = 16, col = "blue",
xlab = "Index", ylab = "Probabilities", main = "True vs Estimated Mean and Standard Deviation")
abline(v = mean_est, col = "red", lwd = 2, lty = 2)
abline(h = known_mean, col = "black", lwd = 2, lty = 2)
legend("topright", legend = c("True Mean", "Estimated Mean"), col = c("black", "red"),
lwd = 2, lty = 2, pch = c(NA, NA), pt.bg = c("black", "red"))
# Generate the probability matrix
n_rows <- 10
n_cols <- 10
true_means <- (1:abins)+0.25  # True means for each column
true_sds <- seq(0.5, 1.5, length.out = n_cols)  # True standard deviations for each column
probs <- matrix(0, nrow = n_rows, ncol = n_cols)
for (j in 1:n_cols) {
probs[, j] <- dnorm(1:n_rows, mean = true_means[j], sd = true_sds[j])
probs[, j] <- probs[, j] / sum(probs[, j])  # Normalize probabilities to sum to 1
}
# Estimate the means for each column
means_est <- numeric(n_cols)
for (j in 1:n_cols) {
init_mean <- 0  # Initial mean value for optimization
# Define the objective function for the current column
objective_col <- function(mean) {
random_vals <- dnorm(1:n_rows, mean = mean, sd = true_sds[j])
random_vals <- random_vals / sum(random_vals)
sum_sq_diff <- sum((probs[, j] - random_vals)^2)
return(sum_sq_diff)
}
optim_result <- optimize(f = objective_col, interval = c(-10, 10))
means_est[j] <- optim_result$minimum
}
# Estimate the standard deviations for each column
sds_est <- numeric(n_cols)
for (j in 1:n_cols) {
# Define the objective function for the current column
objective_sd <- function(sd) {
random_vals <- dnorm(1:n_rows, mean = means_est[j], sd = sd)
random_vals <- random_vals / sum(random_vals)
sum_sq_diff <- sum((probs[, j] - random_vals)^2)
return(sum_sq_diff)
}
optim_result_sd <- optimize(f = objective_sd, interval = c(0, 10), maximum = FALSE)
sds_est[j] <- optim_result_sd$minimum
}
# Print the estimated means and standard deviations
rbind(means_est, true_means)
rbind(sds_est, true_sds)
par(mfrow = c(1, 2))
# Plot true vs estimated means
plot(1:n_cols, true_means, type = "l", col = "black", lwd = 2,
ylim = c(min(true_means, means_est, na.rm = TRUE) - 1, max(true_means, means_est, na.rm = TRUE) + 1),
xlab = "Column", ylab = "Mean", main = "True vs Estimated Means")
points(1:n_cols, means_est, col = "blue", pch = 16)
legend("topright", legend = c("True", "Estimated"), col = c("black", "blue"), lwd = 2, pch = 16)
# Plot true vs estimated standard deviations
plot(1:n_cols, true_sds, type = "l", col = "black", lwd = 2,
ylim = c(min(true_sds, sds_est, na.rm = TRUE) - 0.5, max(true_sds, sds_est, na.rm = TRUE) + 0.5),
xlab = "Column", ylab = "Standard Deviation", main = "True vs Estimated Standard Deviations")
points(1:n_cols, sds_est, col = "blue", pch = 16)
legend("topright", legend = c("True", "Estimated"), col = c("black", "blue"), lwd = 2, pch = 16)
# knitr::opts_chunk$set(echo = FALSE)
options(knitr.table.format = function() {
if (knitr::is_latex_output()) 'latex' else 'pandoc'
})
require(reshape2)
require(dplyr)
require(ggplot2)
abins <- 10
# bias_a <- sort(sapply(1:abins, FUN = function(x) rnorm(1, mean = x, sd = 0.1)))
bias_a <- c(1.1873,	2.2105,	3.23844,	4.27116,	5.30867,	6.351,	7.39816,	8.45019,	9.5071, 10.6357)
sd_a <- rep(0.15, abins)
# sd_a <- c(	0.001, 0.0716628,	0.142271,	0.212825,	0.283324,	0.353768,	0.424158,	0.494494,	0.564775,0.635002)
# sd_a <- sapply(1:abins, FUN = function(x) 0.001+0.005*x)
par(mfrow=c(1,2))
plot( 1:abins,bias_a, type = 'l', xlab = 'true age', ylab = 'bias')
plot( 1:abins, sd_a, type = 'l', xlab = 'true age', ylab = 'sd')
P_aa <- matrix(0, nrow = abins, ncol = abins)
diag(P_aa) <- 1
P_aa
getP_al <- function(theta, aa, sigma, maxage){
pal = NA
if(theta == 1){
pal <- pnorm(theta, aa, sigma)
} else if (theta > 1 & theta < maxage){
pal <- pnorm(theta+1, aa, sigma) - pnorm(theta, aa, sigma)
} else if (theta == maxage){
pal <- 1-pnorm(theta, aa, sigma)
}
pal
}
for(a_obs in 1:abins){
for(a_tilde in 1:abins){
P_aa[a_obs,a_tilde] <- getP_al(theta = a_obs,
aa = bias_a[a_tilde],
sigma = sd_a[a_tilde],
maxage = abins)
} ## aprime
} ## aobs
P_aa[1,1] <- 1
for(a_obs in 1:abins){
P_aa[,a_obs] <- P_aa[,a_obs]/sum(P_aa[,a_obs])
}
all(round(colSums(P_aa))==1)
melt_paa <- melt(P_aa)
ggplot(data = melt_paa, aes(x = Var1, y = value, color = factor(Var2))) +
theme_minimal() +
geom_line(lwd = 1)+
scale_color_grey() +
labs(x = 'True Age', y = 'Probability', color = 'Read Age')
ggplot(data = melt_paa, aes(y = Var1, x = Var2, fill = value)) +
theme_minimal()+
theme(legend.position = 'none')+
geom_tile()+
coord_equal()+
scale_y_reverse() +
scale_x_continuous(position = 'top')+
geom_text(aes(label = round(value, 3)), color = 'yellow', size = 3)+
scale_color_grey() +
labs(x = 'Read Age', y = 'True Age', color = 'Prob')
# Set the known mean and standard deviation
n_bins = 50
known_mean <- n_bins*0.45
known_sd <- n_bins*0.1
# Generate the probabilities from a normal distribution
set.seed(123)  # Set seed for reproducibility
probs <- rnorm(n_bins, mean = known_mean, sd = known_sd)
probs <- probs / sum(probs)  # Normalize probabilities to sum to 1
# Calculate the estimated mean and standard deviation
mean_est <- sum(probs * (1:length(probs)))
sd_est <- sqrt(sum(probs * ((1:length(probs)) - mean_est)^2))
# Print the estimated mean and standard deviation
cat("True Mean:",known_mean, "Estimated Mean:", mean_est, "\n")
cat("True SD:",known_sd,"Estimated Standard Deviation:", sd_est, "\n")
# Plot the comparison
plot(1:length(probs), probs, type = "b", pch = 16, col = "blue",
xlab = "Index", ylab = "Probabilities", main = "True vs Estimated Mean and Standard Deviation")
abline(v = mean_est, col = "red", lwd = 2, lty = 2)
abline(h = known_mean, col = "black", lwd = 2, lty = 2)
legend("topright", legend = c("True Mean", "Estimated Mean"), col = c("black", "red"),
lwd = 2, lty = 2, pch = c(NA, NA), pt.bg = c("black", "red"))
# Generate the probability matrix
n_rows <- 10
n_cols <- 10
true_means <- (1:abins)+0.25  # True means for each column
true_sds <- seq(0.5, 1.5, length.out = n_cols)  # True standard deviations for each column
probs <- matrix(0, nrow = n_rows, ncol = n_cols)
for (j in 1:n_cols) {
probs[, j] <- dnorm(1:n_rows, mean = true_means[j], sd = true_sds[j])
probs[, j] <- probs[, j] / sum(probs[, j])  # Normalize probabilities to sum to 1
}
# Estimate the means for each column
means_est <- numeric(n_cols)
for (j in 1:n_cols) {
init_mean <- 0  # Initial mean value for optimization
# Define the objective function for the current column
objective_col <- function(mean) {
random_vals <- dnorm(1:n_rows, mean = mean, sd = true_sds[j])
random_vals <- random_vals / sum(random_vals)
sum_sq_diff <- sum((probs[, j] - random_vals)^2)
return(sum_sq_diff)
}
optim_result <- optimize(f = objective_col, interval = c(-10, 10))
means_est[j] <- optim_result$minimum
}
# Estimate the standard deviations for each column
sds_est <- numeric(n_cols)
for (j in 1:n_cols) {
# Define the objective function for the current column
objective_sd <- function(sd) {
random_vals <- dnorm(1:n_rows, mean = means_est[j], sd = sd)
random_vals <- random_vals / sum(random_vals)
sum_sq_diff <- sum((probs[, j] - random_vals)^2)
return(sum_sq_diff)
}
optim_result_sd <- optimize(f = objective_sd, interval = c(0, 10), maximum = FALSE)
sds_est[j] <- optim_result_sd$minimum
}
# Print the estimated means and standard deviations
rbind(means_est, true_means)
rbind(sds_est, true_sds)
par(mfrow = c(1, 2))
# Plot true vs estimated means
plot(1:n_cols, true_means, type = "l", col = "black", lwd = 2,
ylim = c(min(true_means, means_est, na.rm = TRUE) - 1, max(true_means, means_est, na.rm = TRUE) + 1),
xlab = "Column", ylab = "Mean", main = "True vs Estimated Means")
points(1:n_cols, means_est, col = "blue", pch = 16)
legend("topright", legend = c("True", "Estimated"), col = c("black", "blue"), lwd = 2, pch = 16)
# Plot true vs estimated standard deviations
plot(1:n_cols, true_sds, type = "l", col = "black", lwd = 2,
ylim = c(min(true_sds, sds_est, na.rm = TRUE) - 0.5, max(true_sds, sds_est, na.rm = TRUE) + 0.5),
xlab = "Column", ylab = "Standard Deviation", main = "True vs Estimated Standard Deviations")
points(1:n_cols, sds_est, col = "blue", pch = 16)
legend("topright", legend = c("True", "Estimated"), col = c("black", "blue"), lwd = 2, pch = 16)
bias_a <- c(1.1873,	2.2105,	3.23844,	4.27116,	5.30867,	6.351,	7.39816,	8.45019,	9.5071, 10.6357)
# sd_a <- rep(0.15, abins)
sd_a <- c(	0.001, 0.0716628,	0.142271,	0.212825,	0.283324,	0.353768,	0.424158,	0.494494,	0.564775,0.635002)
# sd_a <- sapply(1:abins, FUN = function(x) 0.001+0.005*x)
par(mfrow=c(1,2))
plot( 1:abins,bias_a, type = 'l', xlab = 'true age', ylab = 'bias')
ggplot(data = melt_paa, aes(y = Var1, x = Var2, fill = value)) +
theme_minimal()+
theme(legend.position = 'none')+
geom_tile()+
coord_equal()+
scale_y_reverse(expand = c(0,0)) +
scale_x_continuous(position = 'top',expand = c(0,0))+
geom_text(aes(label = round(value, 3)), color = 'yellow', size = 3)+
scale_color_grey() +
labs(x = 'Read Age', y = 'True Age', color = 'Prob')
sd
