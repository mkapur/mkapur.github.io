---
title: Non-rectangular bounding boxes with the sf package
author: Kapur
date: '2020-05-01'
slug: sf-non-rect
categories: []
tags: []
subtitle: ''
summary: ''
authors: []
lastmod: '2020-05-01T14:13:36-07:00'
featured: yes
image:
  placement: 2
  focal_point: ""
  preview_only: false
projects: []

---

This is in the "so I don't forget" category.

For plotting, I wanted to clip an irregular shapefile (namely the EEZ off BC, Canada) based on a sloped line transect -- meaning the simple approach of `sf_crop()` and passing the bounds of a rectangle were insufficient. <a href = "https://r-spatial.github.io/sf/reference/st.html"> This link helped.</a>

I accomplished this once I recognize that one can define a bounding box using a matrix with coordinates at each of the vertices of the desired shape; the terminal entry in the matrix should match the first, effectively outlining the shape you'd like to make. Keep in mind that the coordinates should be on the same scale (even pre-projection) as the shapefile which is going to be clipped with this polygon -- hence the + 360 calls.

On the left is the EEZ; on the right show the two different clips I'd like to make (blue and white). In the code, the blue and white triangles are the p11 and p12 objects, respectively. They haven't yet been projected or changed into polygons.

```{r eval = TRUE, warning = FALSE, message = FALSE}
require(sf) 
require(ggplot2)
require(dplyr)

load("eez_nepac_regions.rda")
regions <- eez_nepac_regions

xmin = -140 + 360
xmax = -125 + 360 
ymin = 45 
ymax = 55 
xdomain <- seq(xmin,xmax, length.out = 100) 
outerLower <- matrix(c(xmin, ymin,xmax,ymin,xmax,ymax,xmin, ymin), ncol=2, byrow=TRUE) 
pts = list(outerLower) 
pl1 = st_polygon(pts)

## note the point-switching
outerUpper <- matrix(c(xmin, ymin,xmin, ymax,xmax,ymax,xmin, ymin), ncol=2, byrow=TRUE) 
pts = list(outerUpper)
p12 = st_polygon(pts)

BCreg <- regions %>% filter(Region_Name == 'British Columbia')

par(mfrow = c(1,2))
plot(BCreg$geometry)
plot(pl1, col = 'gold')
plot(p12, add = TRUE, col = 'blue')
```

The clip step actually uses `sf::st_intersection(`). To simplify things I pass the first argument as a subset of all the regions that includes the shapefile for only BC's EEZ. This can then be plotted within ggplot2.

```{r eval = TRUE, warning = FALSE, message = FALSE}
require(ggplot2)
BCangle_geom <- sf::st_sfc(list(p12), crs = "+proj=longlat +datum=WGS84 +no_defs") 
BCangle_shape <- st_sf(BCangle_geom) 
B1 <- st_intersection(BCreg,BCangle_shape) 

BCangle_geom <- sf::st_sfc(list(pl1), crs = "+proj=longlat +datum=WGS84 +no_defs") 
BCangle_shape <- st_sf(BCangle_geom) 
B2 <- st_intersection(BCreg,BCangle_shape)

require(marmap)
BCbath <- getNOAA.bathy(lon1 = -140, lon2 = -120,
                        lat1 = 45, lat2 = 65, resolution = 4)

splitLat <- function(sample_x = 25, xmin, xmax, ymin, ymax){
  ydiff = ymax - ymin
  xdiff = xmax - xmin
  int = ymin - ydiff/xdiff * xmin
  # split_y <- (ydiff/xdiff)*sample_x + int
  return(list(ydiff, xdiff, int))
}
xmin = -140
xmax = -125 
ydif = splitLat(sample_x = 25, xmin, xmax, ymin, ymax)[[1]]
xdif = splitLat(sample_x = 25, xmin, xmax, ymin, ymax)[[2]]
int = splitLat(sample_x = 25, xmin, xmax, ymin, ymax)[[3]]

p1 <- ggplot(data = regions) +
  geom_sf(data = B1, fill = "gold", alpha = 0.5, color = NA) +
  geom_sf(data = B2, fill= "blue", alpha = 0.5, color = NA) +
  geom_sf(lwd = 1, col = 'black', fill = NA) +
  coord_sf(xlim = c(220, 240), ylim = c(30, 65)) +
  labs(x ="",y="")+
  theme_classic(base_size = 14)
p2 <- autoplot(BCbath, geom=c("r", "c"), colour="white", size=0.05) + 
  scale_fill_etopo() +
  geom_abline(slope = ydif/xdif, intercept = int, col = 'red', lwd = 1.1) +
  
  labs(x ="",y="")+
  theme_classic(base_size = 14)
require(patchwork)
p1 |p2
```

The bathy maps at right were made with marmap.


Other crops throughout the domain, which rely only on purely vertical OR horizontal lines, can be accomplished using a simple call to `sf::st_crop()`. This takes the arguments of lat-long borders of a rectangle.
